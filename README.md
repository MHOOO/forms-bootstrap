# Forms-Bootstrap #
Forms-Bootstrap is a utility for creating web forms in Clojure, styled using 
[Twitter's Bootstrap CSS](http://twitter.github.com/bootstrap/). It is built to be used with the 
[Noir](https://github.com/noir-clojure/noir) web framework, 
[Enlive](https://github.com/cgrand/enlive) HTML templating, and validation using 
[Sandbar](https://github.com/brentonashworth/sandbar).
You can use forms-bootstrap to quickly make nicely styled forms for your web app. It is easy to validate 
your forms and display well formatted error messages next to the appropriate fields. You can also preopulate 
the form with default data from a source of your choice.

I am working on this library in my spare time, and there is much that still needs to be done!

## Usage ##
Supported forms field: 

* input (text or password)
* select (dropdown menus)
* text area
* checkboxes
* radio buttons
* file input

## Examples ##
Once you have cloned the project, navigate to the project directory and:
`lein run`

This lets you view the examples in /test. Open your favorite browser and go to:
`http://localhost:8080/`

## Snippets ##
Forms Bootstrap defines the following snippets listed below. (See 
[Enlive](https://github.com/cgrand/enlive) Templating). Snippets are functions that return 
a collection of nodes. You can use them with Enlive functions such as 'content' that take a sequence of nodes 
and return a transformation function, which you can use in a 'deftemplate' to get a sequence of strings in HTML 
to use in a Noir defpage. Sounds complicated but its actually simple to use and makes templating a cinch!

* basic-form: This is the 'main' snippet that takes in the sequence of 'nodes' generated by the other snippets
that each correspond to a form field type.
* input-field
* text-area-field
* dropdown-menu
* checkbox-or-radio
* file-input
* make-submit-button

## Form-Helper Macro ##
The form-helper macro is really convenient for making forms very quickly. You can call the macro with a name, a
collection of form fields, a validator function, a submit button label, a url to POST to, and functions to 
execute on successful validation and on failed validation. Form-Helper will then create a function bound to the name
you provided the macro. This function can be called with an action (ie users/dpetrovics/edit), a cancel link 
(ie: /users), and a form parameters map (used to pre-populate the form after a page render on failed validation, 
or to provide default values). When called, this function will return the enlive node representation of your form. 
You can use this Enlive map in a deftamplate to put the form into your desired html page, ie: 
(content your-form-name-here). The form-helper macro also creates the POST handler using Noir's defpage. Its route
is the POST url that you provided to the macro and it takes the form params as an argument. The POST handler's body
validates the form params, and then executes either the on-success or on-failure function.

Each 'field' in the :fields portion of a form-helper macro call can contain: 

* name: This assigns a name to the form element
* type: Supported types: text, password, text-area, select, checkbox, radio, file-input. 
* size: Supported sizes: input-mini, input-small, input-medium, input-large, input-xlarge, input-xxlarge, 
as well as span1, span2, span3, etc
* label: What to display next to the form element
* inputs: A vector of [[name1 content1] [name2 content2] ...]. Used by select, checkbox and radio.
* rows: Defines the number of rows for a text area
* text-area-content: A string of default text in a text area

Note: There are quite a few more options that you can provide depending on the form field. You can checkout core.clj 
and browse the arguments that each snippet takes. I will try to document them on the readme soon.

Here is an example:

      (form-helper example-form
         :validator some-validator-fn-here
         :post-url "/users/:username/edit"
         :submit-label "Edit"
         :fields [{:name "first-name"
                   :label "First Name"
                   :type "text"}
                  {:name "last-name"
                   :label "Last Name"
                   :type "text"}
                  {:name "gender"
                   :label "Gender"
                   :type "radio"
                   :inputs [["male" "Male"]
                            ["female" "Female"]]}
                  {:name "email"
                   :label "Email Address"
                   :type "text"}
                  {:name "username"
                   :label "Username"
                   :type "text"}
                  {:name "password"
                   :label "Password"
                   :type "password"}]
         :on-success (fn [{uname :username :as user-map}]
                        (user/edit! user-map)
                        (session/flash-put! :flash "User edited successfully.")
                        (response/redirect "/"))
         :on-failure (fn [form-data]
                        (session/flash-put! :flash "Please Fix Errors")
                        (render "/users/:username/edit" form-data)))
   
Then to use the generated 'example-form' function:

      (defpage "/users/:username/edit"    ;;this is the 'GET' defpage. The 'POST' one is created for you by form-helper
         {:keys[username] :as m}
         (your-enlive-template-here 
            (example-form m   ;;form params map (or default inputs)
                          (str "users/" username "/edit")    ;;the action for the form
                          "/users")))  ;;cancel button link

Your Enlive template should make sure to link to Twitter Bootstrap CSS to make use of their styling.


## TO DO ##
* Should we stick with Sandbar, or move the error handling over to Noir?
* Deal with empty checkboxes, radios, or dropdowns. In this situations the name of the form field is not present in the form params map, so we need a new way of searching for errors (in create-errors-defaults-map).
* More testing.
* Formatting seems to be an issue if we bump from Twitter Bootstrap 2.0.0 to 2.0.4, figure out what's changed


## License ##

Copyright (C) 2012 David Petrovics

Distributed under the Eclipse Public License, the same as Clojure.
