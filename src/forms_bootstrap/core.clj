(ns forms-bootstrap.core
  (:use net.cgrand.enlive-html
        noir.core
        [sandbar.validation :only (if-valid)])
  (:require [noir.validation :as vali]
            [clojure.string :as string]
            [noir.session :as session]
            [noir.response :as response]))

(def form-template "../resources/forms-template.html")

(defn remove-spaces [input]
  (string/replace input " " ""))

;;used by snippets to add "error" to the class of an html element for
;;styling purposes (red text, etc)
(defn handle-error-css [errors]
  (if (peek errors)
     (add-class "error")
     identity))
  
;; SNIPPETS  

;;Grabs the whole form from the template, sets the action, replaces
;;the entire contents with fields, and appends a submit button.
;;fields here is a sequence of stuff generated by all of the
;;defsnippets below, one for each form element
 
(defsnippet basic-form
  form-template
  [:form]              
  [{:keys [action fields submitter class enctype]
    :or {class "form-horizontal"}}]  
  [:form] (do-> (set-attr :action action)
                (set-attr :class class)
                (if (nil? enctype)
                  identity
                  (set-attr :enctype enctype))
                (content fields)   
                (append submitter))) ;; append submit button to end of form
 

;; Generates a txt or password input form field for a given map
;; inputs: name label type size default errors
;; default values: size "xlarge" type "text"
;; ex: [:name "namehere" :label "labelhere" :type "text" :size
;; "xlarge" :errors ["some error"] :default "john"] 

(defsnippet input-field
  form-template
  [:div.input-field]
  [{:keys [id hidden name label class type size errors default disabled placeholder span] 
    :or {size "xlarge"
         type "text"
         default ""}}]
  [:.input-field] (do->
                   (if id
                     (set-attr :id id)
                     identity)
                   (if hidden
                     (add-class "hidden")
                     identity)) 
   
  [:label] (do-> (content label) 
                 (set-attr :for name))
  [:div.controls :input] (do->
                          (set-attr :name name)
                          (set-attr :type type)
                          (set-attr :class size)
                          (set-attr :placeholder placeholder)
                          (if (= disabled true)
                            (set-attr :disabled "")
                            identity)
                          (set-attr :value default)
                          (if (not (empty? class))
                            (set-attr :class class) 
                            identity))    
  ;; better to append "error" to existing attributes of class?
  [:div.input-field] (handle-error-css errors)  
  [:span.help-inline]  (cond
                         (peek errors)
                         (content (peek errors))
                         (not (nil? span) )
                         (content span)
                         :else
                         (content "")))
 

;;creates a text-area form element
;;inputs: name, label, size, rows, default, errors
;;default values: size-"xlarge" rows-"3"
;; ex: [:name "namehere" :label "labelhere" :type "text-area"
;;      :size "xlarge" :rows "3" :default "defaultstuff"]

(defsnippet text-area-field 
  form-template
  [:div.text-area]
  [{:keys [name label size rows errors default]
    :or {size "xlarge"
         rows "3"
         default ""}}]
  [:label] (do-> (set-attr :for name)
                 (content label))
  [:textarea] (do-> (set-attr :class size)
                    (set-attr :name name)
                    (set-attr :rows rows)
                    (content default))
  [:div.text-area] (handle-error-css errors)
  [:span.help-inline]  (if-let [err (peek errors)]
                         (content err)
                         (content)))


;; creates a select (dropdown) form element with the given values 
;; inputs: name, type, size, label, inputs vector [value, value-label,
;;   value, value-label, etc] 
;; ex: {:type "select" :name "cars" :size "xlarge" :label "Cars"
;;      :inputs [["volvo" "Volvo"] ["honda" "Honda"]]}
;; Add errors, default functionality
;;it needs to be selector, function pairs
;; (set-attr :value value) returns a function that modifies the html
;; do-> chains functions together
(defsnippet dropdown-menu
  form-template                       
  [:div.select-dropdown] 
  [{:keys [name size label inputs errors default type]
    :or {size "xlarge"}}]
  [:label] (do-> (content label) 
                 (set-attr :for name))
  [:select] (do-> (set-attr :name name
                            :class size
                            :id name)
                  (if (= type "select inline")
                    identity
                    (wrap :div {:class "controls"})))
  ;;set input options here
  [:select :option] (clone-for [[value value-label] inputs]
                               (do-> (set-attr :value value)
                                     (if (= default value)
                                       (set-attr :selected "selected")  
                                       identity)
                                     (content value-label)))
  ;;deal with errors
  [:div.select-dropdown] (handle-error-css errors)
  [:span.help-inline]  (if-let [err (peek errors)]
                         (content err)
                         (content))) 

;;takes in one arg, and returns it if its already a vector- ["athlete"
;;"coach"], or makes it into a vector - "athlete" => ["athlete"]

(defn collectify [x]
  (if (sequential? x) x [x]))

;;takes an input string x and returns the first word in x

(defn first-word [x]
 (clojure.core/get (string/split x #"\s") 0))

;;creates a radio or checkbox form list with the given attributes
  ;; args: type, name, label, note, inputs[[name val][name val]...] 
  ;; ex: {:type "select" :name "cars" :size "xlarge" :label "Cars"
  ;;      :inputs [["volvo" "Volvo"] ["honda" "Honda"]]}
  
(defsnippet checkbox-or-radio
  form-template                       
  [:.checkbox-or-radio] 
  [{:keys [name label inputs note type errors default class]}]
  [:div.checkbox-or-radio]  (add-class class)
  [:label.control-label] (do-> (content label)  
                               (set-attr :name name))
  ;;deal with the inputs vector here (clone-for ....)  
  [:div.controls :label] (clone-for [[value value-label] inputs] 
                                    [:label] (add-class type)
                                    [:input] (do-> (set-attr :type (first-word type)
                                                             :name name
                                                             :value value
                                                             :id (remove-spaces
                                                                  value-label))
                                                   (content value-label)
                                                   (if (contains?
                                                        (set (collectify default))
                                                        value)
                                                     (set-attr :checked "checked")
                                                     identity)))
  ;;errors here 
  [:div.checkbox-or-radio] (handle-error-css errors)
  [:span.help-block] (content (or (peek errors)
                                  note)))
   
;;creates html for a file input
(defsnippet file-input
  form-template
  [:div.file-input]
  [{:keys [name label errors]}]
  [:label] (content label)
  [:input] (set-attr :name name)
  ;;errors
  [:div.file-input] (handle-error-css errors)
  [:span.help-inline] (if-let [err (peek errors)]
                        (content err)
                        (content)))
  


;;creates code for a submit button with a specified label (value)
;;add support for different types of buttons within <div class="actions">
(defsnippet make-submit-button  
  form-template
  [:div#submit_button]
  [label cancel-link] 
  [:button] (content label)
  [:a] (if cancel-link
         (if (= cancel-link "modal") 
           (set-attr :data-dismiss "modal")
           (set-attr :href cancel-link))
         (content ""))) 

(defsnippet login-helpers form-template [:#more_info] [])

;;takes a source and makes a script
(defsnippet make-script
  form-template
  [:div#form-scripts]
  [{:keys [source]
    :or {source "cljs/calendar.js"}}]
  [:script] (set-attr :src source))

;;HELPERS 

;;make-field takes a single map representing a form element's
;;  attributes and routes it to the correct snippet based on its type
;;ex: {:type "text" :name "username" :label "Username"}
;;Supported form elements: input field, text area, dropdown menu,
;;  checkbox, radio buttons
;; the map m will also have :errors :default appended on to it, ex:
;; {:type "text" :name "username" :label "Username" :errors ["some err"] :default ""}
(defn make-field
  [m]
  ;; (println (str "MAKE-FIELD: " m))
  ;; we get just the first word from the :type in the field-- since we
  ;; could have something like "radio inline"
  (case (first-word (:type m))
    "text"       (input-field m)
    "password"   (input-field (dissoc m :default)) ;;dont want to keep passwords
    "text-area"  (text-area-field m)
    "select"     (dropdown-menu m)
    "radio"      (checkbox-or-radio m)
    "checkbox"   (checkbox-or-radio m)
    "file-input" (file-input m)))

;;Returns a form with the specified action, fields, and submit button.
;;It can take nothing or optionally an action, fields, submit-label.
;;It generates the fields by mapping make-field over all form elements
;;  in fields
;;Action is the route to post to, for ex: "/session"
;;Fields is a seq. of maps, ea containing a form element's attributes
;;  ex: ({:type "text" :name "username" :label "Username"}
;;       {:type "pass" :name "password" :label "Password"})
;; after we merge with errors / defs, one field could look like:
;; {:type "text" :name "username" :errors ["username cannot be blank"] :default ""}
;;Submit-Label is the label on the submit button - default is "Submit"

;;add options for inline, and for no submit button
(defn make-form
  [& {:keys [action class fields submit-label errors-and-defaults enctype cancel-link]
      :or {class "form-horizontal"}}]
  ;; (println  "MAKE-FORM errors-and-defaults: " errors-and-defaults)
  ;; (println "FIELDS: " fields)
  ;; (println "ACTION: " action)
  (basic-form {:action    action
               :class class
               :enctype  enctype
               :fields   (map (fn [{:keys [name] :as m}]
                                (make-field
                                 ;;maps make-field across each form
                                 ;;element after its has been merged
                                 ;;with any errors or default values 
                                 (merge m
                                        (get errors-and-defaults
                                             (keyword
                                              ;;replace [] in case its
                                              ;;the name of a form
                                              ;;element that can take
                                              ;;on mutliple values (ie checkbox)
                                              (string/replace name "[]" ""))))))
                              fields) 
               :submitter (when submit-label
                            (make-submit-button submit-label cancel-link))}))


;; used by defform macro. converts sandbar errors to noir errors
;; @vali/*errors* looks like:
;;  {:title [["title must be an integer number!"]], :location [["location cannot be blank!"]]}
(defn move-errors-to-noir
  "Moves errors over to Noir and returns the form-data."
  [form-data errors]
  (doseq [[field [error]] errors]
    (vali/set-error field error))
  form-data)


;;creates an errors / defaults map for a given params map
;;ex:
;; { :description {:errors ["description cannot be blank!"], :default ""}
;; :location {:errors nil, :default "fda"}, :title {:errors
;; ["title cannot be blank!"], :default ""}}
(defn create-errors-defaults-map [m]
  (println "errs-defs " m)
  (into {} (for [[k v] m]
             [(keyword k) {:errors (vali/on-error (keyword k) identity)
                           :default v}]))) 
  
  
;;Takes a validator function, an action (route) to POST to, a sequence of maps
;;each containing a form element's attributes, and a function to call
;;in the POST handler on success
;; pass this an on-fail function, and replace (store-errors... ) line
;;with ~on-fail, and get rid of the (let [failure...) line
(defmacro defform 
  "Generates a form and registers a POST handler with Noir. TODO: Docs!"
  [sym & {:keys [validator action fields on-success on-failure]
          :or {on-success (constantly (response/redirect "/"))
               validator  identity}
          :as opts}] ;;opts is a map 
  (assert (and action fields on-failure)
          "Please provide :action, :fields and :on-failure to defform.")
  `(do 
     (defn ~sym
       ([] (make-form ~@(apply concat opts))) ;;calls (make-form key
       ;;val key val ...)
       ([form-params#] ;;puts the 1st () as the last arg to the 2nd (), etc
          (->> (create-errors-defaults-map form-params#)
               (assoc ~opts :errors-and-defaults)
               (apply concat)
               (apply make-form)))
       ([form-params# action#]
          (->> (create-errors-defaults-map form-params#)
               (assoc (assoc ~opts :action action#) :errors-and-defaults)
               (apply concat)
               (apply make-form))))
       
     (defpage [:post ~action] {:as m#} ;;m#=params from request map
       ;;if-valid: (if m# passes validation)
       ;; (~on-success m#)
       ;; else (~on-failure (dissoc m# :_validation-errors) errors#) 
       (if-valid ~validator m#
                 ~on-success
                 (comp ~on-failure move-errors-to-noir)))))

(defmacro defform-lite
  "Generates a form with the given inputs"
  [sym & {:as opts}]
  `(do 
     (defn ~sym
       ([form-params# action#]
          (->> (create-errors-defaults-map form-params#)
               (assoc (assoc ~opts :action action#) :errors-and-defaults)
               (apply concat)
               (apply make-form))))))

(defn insert-custom-inputs [opts custom-inputs]
  (if (seq custom-inputs)
    (into []
          (for [field (:fields opts)]
            (if-let [akey (keyword (:name field))] 
              (assoc field :inputs 
                     (akey custom-inputs)))))
    (vec (:fields opts))))

(defmacro defform-custom-post
  "Generates a form with the given inputs. Also generates a post handler for the given url"
  [sym & {:keys [validator fields on-success on-failure post-url] :as opts}]
  (assert (and validator fields on-success on-failure post-url)
          "Please provide :validator, :fields, :on-success, :on-failure and :post-url to defform.")
  `(do 
     (defn ~sym 
       ([form-params# action#]
          (->> (create-errors-defaults-map form-params#)
               (assoc (assoc ~opts :action action#) :errors-and-defaults)
               (apply concat)
               (apply make-form)))
       ([form-params# action# cancel-link# custom-inputs#] 
          (->> (create-errors-defaults-map form-params#)
               (assoc (-> (assoc ~opts :fields (insert-custom-inputs ~opts custom-inputs#))
                          (assoc :action action#)
                          (assoc :cancel-link cancel-link#))
                 :errors-and-defaults)
               (apply concat)
               (apply make-form))))
     (defpage [:post ~post-url] {:as m#}  
       (if-valid ~validator m#
                 ~on-success
                 (comp ~on-failure move-errors-to-noir)))))
